<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DINOv3 Object Detection - MultiWebApp</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Times New Roman', serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0d1b1b 100%);
            min-height: 100vh;
            color: #ffffff;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px;
        }

        .header {
            text-align: center;
            margin-bottom: 15px;
            color: white;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-weight: normal;
        }

        .header p {
            font-size: 1rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        .card {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            border: 1px solid rgba(185, 29, 48, 0.3);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 30px rgba(0,0,0,0.4);
            border-color: #B91D30;
        }

        .card h2 {
            color: #ffffff;
            margin-bottom: 10px;
            font-size: 1.2rem;
            font-weight: normal;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .upload-section {
            margin-bottom: 15px;
        }

        .upload-options {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .upload-btn {
            flex: 1;
            padding: 10px;
            border: 2px dashed #B91D30;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(0, 0, 0, 0.3);
            color: #ffffff;
            font-size: 0.9rem;
        }

        .upload-btn:hover {
            background: rgba(185, 29, 48, 0.1);
            color: white;
            border-color: #ffffff;
        }

        .upload-btn.active {
            background: rgba(185, 29, 48, 0.2);
            color: white;
            border-color: #B91D30;
        }

        .upload-btn i {
            font-size: 2rem;
            margin-bottom: 10px;
            display: block;
        }

        .file-input {
            display: none;
        }

        .model-selection {
            margin-bottom: 25px;
        }

        .model-selection label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #ffffff;
            transition: color 0.3s ease;
        }

        .model-selection:has(.model-dropdown:disabled) label {
            color: #888888;
        }

        .model-dropdown {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #333333;
            border-radius: 10px;
            font-size: 1rem;
            background: rgba(0, 0, 0, 0.6);
            color: #ffffff;
            transition: border-color 0.3s ease;
        }

        .model-dropdown:focus {
            outline: none;
            border-color: #B91D30;
        }

        .model-dropdown:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: rgba(0, 0, 0, 0.3);
            color: #888888;
        }

        .image-controls {
            margin-bottom: 15px;
            display: none !important;
        }

        .control-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }

        .control-item {
            display: flex;
            flex-direction: column;
        }

        .control-item label {
            margin-bottom: 3px;
            font-weight: normal;
            color: #ffffff;
            font-size: 0.8rem;
        }

        .control-item input {
            padding: 8px;
            border: 2px solid #333333;
            border-radius: 6px;
            font-size: 0.8rem;
            background: rgba(0, 0, 0, 0.6);
            color: #ffffff;
            transition: border-color 0.3s ease;
        }

        .control-item input:focus {
            outline: none;
            border-color: #B91D30;
        }

        /* Detection Results Container - Match Architecture Details Width */
        #detectionResultsContainer {
            width: 100%;
            max-width: none;
            margin-bottom: 15px;
            border: 2px solid #333333;
            border-radius: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.6);
            box-sizing: border-box;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .preview-header h4 {
            color: #ffffff;
            margin: 0;
            font-size: 1rem;
            font-weight: normal;
        }

        .reset-crop-btn {
            padding: 6px 12px;
            background: #B91D30;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: background 0.3s ease;
        }

        .reset-crop-btn:hover {
            background: #CC0000;
        }

        .image-preview-wrapper {
            position: relative;
            display: inline-block;
            border: 2px solid #333333;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .image-preview-canvas {
            max-width: 100%;
            max-height: 300px;
            cursor: crosshair;
            display: block;
        }

        #resultImage {
            width: 100%;
            height: auto;
            max-height: 300px;
            border-radius: 8px;
            object-fit: contain;
            display: block;
            margin: 0 auto;
        }

        .crop-overlay {
            position: absolute;
            border: 2px dashed #B91D30;
            background: rgba(185, 29, 48, 0.1);
            pointer-events: none;
            display: none;
        }

        .crop-instructions {
            color: #cccccc;
            font-size: 0.9rem;
            text-align: center;
            font-style: italic;
        }

        /* Batch Navigation Styles */
        .batch-navigation {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            border: 2px solid #333333;
            text-align: center;
        }

        .batch-info {
            margin-bottom: 15px;
            color: #ffffff;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .batch-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
        }

        .batch-controls .btn {
            padding: 10px 20px;
            font-size: 0.9rem;
            min-width: 120px;
        }

        .batch-controls .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: rgba(0, 0, 0, 0.3);
            color: #888888;
            border-color: #555555;
        }

        /* Compact Controls */
        .compact-controls {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            border: 2px solid #333333;
        }

        .control-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .control-group-compact {
            display: flex;
            flex-direction: column;
            min-width: 60px;
        }

        .control-group-compact label {
            font-size: 0.8rem;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 3px;
        }

        .control-group-compact input {
            padding: 6px 8px;
            border: 1px solid #333333;
            border-radius: 6px;
            font-size: 0.8rem;
            width: 60px;
            background: rgba(0, 0, 0, 0.6);
            color: #ffffff;
            transition: border-color 0.3s ease;
        }

        .control-group-compact input:focus {
            outline: none;
            border-color: #B91D30;
        }

        .transform-buttons-compact {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            justify-content: center;
        }

        .transform-btn-small {
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #333333;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            color: #ffffff;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 36px;
            height: 36px;
        }

        .transform-btn-small:hover {
            background: #B91D30;
            color: white;
            border-color: #B91D30;
            transform: translateY(-1px);
        }

        .transform-btn-small.reset-btn {
            background: #f56565;
            color: white;
            border-color: #f56565;
        }

        .transform-btn-small.reset-btn:hover {
            background: #e53e3e;
            border-color: #e53e3e;
        }

        .status-display {
            display: flex;
            justify-content: space-between;
            color: #cccccc;
            font-size: 0.8rem;
            font-weight: 600;
            text-align: center;
        }

        .detect-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #B91D30, #CC0000);
            color: white;
            border: none;
            border-radius: 15px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .detect-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(185, 29, 48, 0.3);
        }

        .detect-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .performance-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-card {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #333333;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: normal;
            color: #B91D30;
            margin-bottom: 3px;
        }

        .stat-label {
            color: #cccccc;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .prediction-result {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 20px;
        }

        .prediction-result.error {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
        }

        .prediction-class {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .prediction-confidence {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .architecture-details {
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #333333;
        }

        .architecture-details h3 {
            color: #ffffff;
            margin-bottom: 10px;
            font-size: 1.1rem;
            font-weight: normal;
        }

        .detail-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .detail-item {
            text-align: center;
        }

        .detail-label {
            color: #cccccc;
            font-size: 0.7rem;
            margin-bottom: 3px;
            font-weight: normal;
        }

        .detail-value {
            color: #ffffff;
            font-weight: normal;
            font-size: 0.9rem;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #333333;
            border-top: 4px solid #B91D30;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #fed7d7;
            color: #c53030;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 2px solid #feb2b2;
        }

        .success-message {
            background: #c6f6d5;
            color: #2f855a;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 2px solid #9ae6b4;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 1.5rem;
            }
            
            .control-group {
                grid-template-columns: 1fr;
            }
            
            .performance-stats {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .control-row {
                justify-content: center;
            }
            
            .control-group-compact {
                min-width: 50px;
            }
            
            .control-group-compact input {
                width: 50px;
            }
            
            .transform-buttons-compact {
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .status-display {
                flex-direction: column;
                gap: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
        </div>

        <div id="errorMessage" class="error-message" style="display: none;"></div>
        <div id="successMessage" class="success-message" style="display: none;"></div>

        <div class="main-content">
            <div class="card">
                <h2><i class="fas fa-upload"></i> Image Upload & Processing</h2>
                
                <div class="upload-section">
                    <div class="upload-options">
                        <div class="upload-btn active" id="singleUploadBtn">
                            <i class="fas fa-image"></i>
                            <div>Single Image</div>
                        </div>
                        <div class="upload-btn" id="batchUploadBtn">
                            <i class="fas fa-images"></i>
                            <div>Batch Upload</div>
                        </div>
                    </div>
                    
                    <input type="file" id="singleFileInput" class="file-input" accept="image/*">
                    <input type="file" id="batchFileInput" class="file-input" accept="image/*" multiple>
                </div>

                <div class="model-selection">
                    <label for="modelSelect"><i class="fas fa-cogs"></i> Select Model Weight:</label>
                    <select id="modelSelect" class="model-dropdown" disabled>
                        <option value="">Upload an image first...</option>
                    </select>
                </div>

                <!-- Image Preview and Controls (hidden until image uploaded) -->
                <div class="image-controls" id="imageControls" style="display: none;">
                    <h3><i class="fas fa-crop"></i> Image Controls</h3>
                    
                    <!-- Image Preview and Crop Area -->
                    <div class="image-preview-container" id="imagePreviewContainer">
                        <div class="preview-header">
                            <h4>Image Preview & Crop</h4>
                        </div>
                        <div class="image-preview-wrapper">
                            <canvas id="imagePreview" class="image-preview-canvas"></canvas>
                            <div class="crop-overlay" id="cropOverlay"></div>
                        </div>
                        <div class="crop-instructions">
                            <i class="fas fa-info-circle"></i>
                            Drag to select crop area. Detection will only analyze the selected region.
                        </div>
                    </div>

                    <!-- Batch Navigation Controls (hidden until batch upload) -->
                    <div class="batch-navigation" id="batchNavigation" style="display: none;">
                        <div class="batch-info">
                            <span id="batchCounter">Image 1 of 1</span>
                        </div>
                        <div class="batch-controls">
                            <button type="button" id="prevImageBtn" class="btn btn-secondary">
                                <i class="fas fa-chevron-left"></i> Previous
                            </button>
                            <button type="button" id="nextImageBtn" class="btn btn-secondary">
                                Next <i class="fas fa-chevron-right"></i>
                            </button>
                        </div>
                    </div>

                    <!-- Compact Controls Row -->
                    <div class="compact-controls">
                        <div class="control-row">
                            <div class="control-group-compact">
                                <label>Crop X:</label>
                                <input type="number" id="cropX" value="0" min="0" onchange="updateCropFromInputs()">
                            </div>
                            <div class="control-group-compact">
                                <label>Crop Y:</label>
                                <input type="number" id="cropY" value="0" min="0" onchange="updateCropFromInputs()">
                            </div>
                            <div class="control-group-compact">
                                <label>Width:</label>
                                <input type="number" id="cropW" value="400" min="1" onchange="updateCropFromInputs()">
                            </div>
                            <div class="control-group-compact">
                                <label>Height:</label>
                                <input type="number" id="cropH" value="300" min="1" onchange="updateCropFromInputs()">
                            </div>
                        </div>
                        
                        <div class="transform-buttons-compact">
                            <button type="button" class="transform-btn-small" onclick="rotateImage(90)" title="Rotate 90째">
                                <i class="fas fa-redo"></i>
                            </button>
                            <button type="button" class="transform-btn-small" onclick="rotateImage(-90)" title="Rotate -90째">
                                <i class="fas fa-undo"></i>
                            </button>
                            <button type="button" class="transform-btn-small" onclick="flipImage('horizontal')" title="Flip Horizontal">
                                <i class="fas fa-arrows-alt-h"></i>
                            </button>
                            <button type="button" class="transform-btn-small" onclick="flipImage('vertical')" title="Flip Vertical">
                                <i class="fas fa-arrows-alt-v"></i>
                            </button>
                            <button type="button" class="transform-btn-small reset-btn" onclick="resetCrop()" title="Reset Crop">
                                <i class="fas fa-undo"></i>
                            </button>
                        </div>
                        
                        <div class="status-display">
                            <span>Rotation: <span id="rotationAngle">0째</span></span>
                            <span>Flip: <span id="flipStatus">None</span></span>
                        </div>
                    </div>
                </div>

                <button class="detect-btn" id="detectBtn" onclick="detectImage()">
                    <i class="fas fa-search"></i>
                    Detect Objects
                </button>
                
                <!-- Loading indicator -->
                <div id="loading" class="loading" style="display: none;">
                    <div class="spinner"></div>
                    <span>Processing...</span>
                </div>
            </div>

            <div class="card">
                <h2><i class="fas fa-chart-line"></i> Performance & Architecture</h2>
                
                <div class="performance-stats">
                    <div class="stat-card">
                        <div class="stat-value" id="inferenceTime">--</div>
                        <div class="stat-label">Inference Time</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="modelSize">86M</div>
                        <div class="stat-label">Parameters</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="inputSize">224x224</div>
                        <div class="stat-label">Input Size</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="batchSize">1</div>
                        <div class="stat-label">Batch Size</div>
                    </div>
                </div>

                <div class="architecture-details">
                    <h3><i class="fas fa-microchip"></i> Architecture Details</h3>
                    <div class="detail-grid">
                        <div class="detail-item">
                            <div class="detail-label">Model Type</div>
                            <div class="detail-value" id="architecture">DINOv3 ViT</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Backbone</div>
                            <div class="detail-value">Vision Transformer</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Attention Heads</div>
                            <div class="detail-value">12</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Layers</div>
                            <div class="detail-value">12</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Embedding Dim</div>
                            <div class="detail-value">768</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Patch Size</div>
                            <div class="detail-value">16x16</div>
                        </div>
                    </div>
                </div>

                <!-- Detection Results (compact style) -->
                <div class="image-preview-container" id="detectionResultsContainer" style="display: none;">
                    <div class="preview-header">
                        <h4><i class="fas fa-search"></i> Detection Results</h4>
                    </div>
                    <div class="image-preview-wrapper">
                        <img id="resultImage" class="image-preview-canvas" alt="Detection Result">
                    </div>
                    <div class="prediction-result" id="predictionResult" style="margin-top: 10px; padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 8px;">
                        <div class="prediction-class" id="predictionClass" style="font-size: 1.1rem; font-weight: bold; color: #9ae6b4; margin-bottom: 6px;"></div>
                        <div class="prediction-confidence" id="predictionConfidence" style="font-size: 0.9rem; color: #ffffff; margin-bottom: 8px;"></div>
                        <div class="top3-predictions" id="top3Predictions" style="font-size: 0.8rem; color: #ffffff;">
                            <div class="prediction-entry" id="prediction1">1. -</div>
                            <div class="prediction-entry" id="prediction2">2. -</div>
                            <div class="prediction-entry" id="prediction3">3. -</div>
                        </div>
                    </div>
                </div>
                </div>
            </div>

        </div>

    <script>
        let currentUploadMode = 'single';
        let selectedFile = null;
        let currentImage = null;
        let cropStartX = 0, cropStartY = 0;
        let isDragging = false;
        let currentRotation = 0;
        let currentFlip = { horizontal: false, vertical: false };
        
        // Batch upload variables
        let batchFiles = [];
        let currentBatchIndex = 0;

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            setupUploadHandlers();
            setupCropHandlers();
            setupBatchNavigation();
        });

        function setupUploadHandlers() {
            const singleBtn = document.getElementById('singleUploadBtn');
            const batchBtn = document.getElementById('batchUploadBtn');
            const singleInput = document.getElementById('singleFileInput');
            const batchInput = document.getElementById('batchFileInput');

            singleBtn.addEventListener('click', () => {
                console.log('Single upload button clicked');
                currentUploadMode = 'single';
                singleBtn.classList.add('active');
                batchBtn.classList.remove('active');
                singleInput.click();
            });

            batchBtn.addEventListener('click', () => {
                console.log('Batch upload button clicked');
                currentUploadMode = 'batch';
                batchBtn.classList.add('active');
                singleBtn.classList.remove('active');
                batchInput.click();
            });

            singleInput.addEventListener('change', handleFileSelect);
            batchInput.addEventListener('change', handleFileSelect);
        }

        function handleFileSelect(event) {
            console.log('File select event triggered');
            const files = event.target.files;
            console.log('Files selected:', files.length);
            
            if (files.length > 0) {
                console.log('Current upload mode:', currentUploadMode);
                console.log('First file:', files[0].name);
                
                if (currentUploadMode === 'batch') {
                    // Handle batch upload
                    batchFiles = Array.from(files);
                    currentBatchIndex = 0;
                    selectedFile = batchFiles[0];
                    
                    console.log('Batch upload - files count:', batchFiles.length);
                    showMessage(`Selected ${batchFiles.length} images for batch processing`, 'success');
                    displayImagePreview(selectedFile);
                    showBatchNavigation();
                } else {
                    // Handle single upload
                    selectedFile = files[0];
                    console.log('Single upload - file:', selectedFile.name);
                    showMessage(`Selected: ${selectedFile.name}`, 'success');
                    displayImagePreview(selectedFile);
                    hideBatchNavigation();
                }
            } else {
                console.log('No files selected');
            }
        }

        function displayImagePreview(file) {
            console.log('displayImagePreview called with file:', file.name);
            console.log('File type:', file.type);
            console.log('File size:', file.size);
            
            // Validate file type
            if (!file.type.startsWith('image/')) {
                console.error('Invalid file type:', file.type);
                showMessage('Please select a valid image file', 'error');
                return;
            }
            
            // Check file size (limit to 10MB)
            if (file.size > 10 * 1024 * 1024) {
                console.error('File too large:', file.size);
                showMessage('Image file is too large (max 10MB)', 'error');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                console.log('FileReader loaded successfully');
                console.log('FileReader result length:', e.target.result.length);
                console.log('FileReader result type:', typeof e.target.result);
                
                // Validate the base64 data
                const base64Data = e.target.result;
                if (!base64Data.startsWith('data:image/')) {
                    console.error('Invalid data URL format');
                    showMessage('Invalid image file format', 'error');
                    return;
                }
                
                // Check for common image format headers
                const imageData = base64Data.split(',')[1];
                const binaryData = atob(imageData);
                const header = binaryData.substring(0, 10);
                console.log('Image header bytes:', Array.from(header).map(b => b.charCodeAt(0)));
                
                // Check for JPEG header (starts with FF D8)
                if (file.type === 'image/jpeg' && !(header.charCodeAt(0) === 0xFF && header.charCodeAt(1) === 0xD8)) {
                    console.error('Invalid JPEG header');
                    showMessage('Invalid JPEG file - file may be corrupted', 'error');
                    return;
                }
                
                // Check for PNG header (starts with 89 50 4E 47)
                if (file.type === 'image/png' && !(header.charCodeAt(0) === 0x89 && header.charCodeAt(1) === 0x50 && header.charCodeAt(2) === 0x4E && header.charCodeAt(3) === 0x47)) {
                    console.error('Invalid PNG header');
                    showMessage('Invalid PNG file - file may be corrupted', 'error');
                    return;
                }
                
                const img = new Image();
                
                // Set a timeout for image loading
                const loadTimeout = setTimeout(() => {
                    console.error('Image loading timeout');
                    showMessage('Image loading timeout - file may be corrupted', 'error');
                }, 10000); // 10 second timeout
                
                img.onload = function() {
                    clearTimeout(loadTimeout);
                    console.log('Image loaded successfully, size:', img.width, 'x', img.height);
                    
                    // Check if image dimensions are valid
                    if (img.width === 0 || img.height === 0) {
                        console.error('Invalid image dimensions:', img.width, 'x', img.height);
                        showMessage('Invalid image dimensions', 'error');
                        return;
                    }
                    
                    currentImage = img;
                    const canvas = document.getElementById('imagePreview');
                    const ctx = canvas.getContext('2d');
                    
                    if (!ctx) {
                        console.error('Could not get canvas context');
                        showMessage('Error initializing image preview', 'error');
                        return;
                    }
                    
                    console.log('Canvas context obtained successfully');
                    
                    // Calculate display size (max 300px height)
                    const maxHeight = 300;
                    const maxWidth = 400;
                    let { width, height } = img;
                    
                    if (height > maxHeight) {
                        width = (width * maxHeight) / height;
                        height = maxHeight;
                    }
                    if (width > maxWidth) {
                        height = (height * maxWidth) / width;
                        width = maxWidth;
                    }
                    
                    console.log('Canvas display size:', width, 'x', height);
                    canvas.width = width;
                    canvas.height = height;
                    
                    // Apply current transformations
                    ctx.save();
                    
                    // Apply rotation
                    if (currentRotation !== 0) {
                        ctx.translate(width / 2, height / 2);
                        ctx.rotate((currentRotation * Math.PI) / 180);
                        ctx.translate(-width / 2, -height / 2);
                    }
                    
                    // Apply flip
                    if (currentFlip.horizontal) {
                        ctx.scale(-1, 1);
                        ctx.translate(-width, 0);
                    }
                    if (currentFlip.vertical) {
                        ctx.scale(1, -1);
                        ctx.translate(0, -height);
                    }
                    
                    try {
                        ctx.drawImage(img, 0, 0, width, height);
                        ctx.restore();
                        console.log('Image drawn to canvas successfully');
                    } catch (canvasError) {
                        console.error('Canvas drawing error:', canvasError);
                        // Fallback: show image directly
                        canvas.style.display = 'none';
                        const imgElement = document.createElement('img');
                        imgElement.src = e.target.result;
                        imgElement.style.maxWidth = '100%';
                        imgElement.style.maxHeight = '300px';
                        imgElement.style.borderRadius = '8px';
                        imgElement.onload = function() {
                            console.log('Fallback image loaded successfully');
                        };
                        imgElement.onerror = function(err) {
                            console.error('Fallback image also failed to load:', err);
                        };
                        canvas.parentNode.appendChild(imgElement);
                        console.log('Fallback image element created');
                    }
                    
                    // Show image controls and preview container
                    const imageControls = document.getElementById('imageControls');
                    // Image controls are hidden via CSS
                    
                    // Enable model selection after image is uploaded
                    enableModelSelection();
                    console.log('Model selection enabled');
                    
                    // Initialize crop values to full image dimensions (only if no crop is active)
                    if (!isCropActive()) {
                        document.getElementById('cropX').value = 0;
                        document.getElementById('cropY').value = 0;
                        document.getElementById('cropW').value = width;  // Use full width
                        document.getElementById('cropH').value = height; // Use full height
                        console.log('Crop values initialized to full image:', width, 'x', height);
                    } else {
                        console.log('Crop is active, maintaining existing crop values');
                    }
                    
                    // Update the crop overlay only (no preview image)
                    updateCropPreview();
                    
                    // Hide detection results when new image is loaded
                    const detectionResultsContainer = document.getElementById('detectionResultsContainer');
                    detectionResultsContainer.style.display = 'none';
                };
                img.onerror = function(e) {
                    clearTimeout(loadTimeout);
                    console.error('Image load error:', e);
                    console.error('Image src:', img.src);
                    console.error('File type:', file.type);
                    console.error('File size:', file.size);
                    showMessage(`Error loading image: ${file.name} - file may be corrupted`, 'error');
                };
                
                img.src = e.target.result;
                console.log('Image src set to:', img.src.substring(0, 100) + '...');
            };
            
            reader.onerror = function(e) {
                console.error('FileReader error:', e);
                showMessage('Error reading file', 'error');
            };
            
            reader.readAsDataURL(file);
        }

        function setupCropHandlers() {
            const canvas = document.getElementById('imagePreview');
            
            canvas.addEventListener('mousedown', startCrop);
            canvas.addEventListener('mousemove', updateCrop);
            canvas.addEventListener('mouseup', endCrop);
            canvas.addEventListener('mouseleave', endCrop);
        }

        function startCrop(e) {
            if (!currentImage) return;
            
            isDragging = true;
            const canvas = document.getElementById('imagePreview');
            const rect = canvas.getBoundingClientRect();
            
            cropStartX = e.clientX - rect.left;
            cropStartY = e.clientY - rect.top;
            
            updateCropOverlay(cropStartX, cropStartY, 0, 0);
        }

        function updateCrop(e) {
            if (!isDragging || !currentImage) return;
            
            const canvas = document.getElementById('imagePreview');
            const rect = canvas.getBoundingClientRect();
            
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;
            
            const cropX = Math.min(cropStartX, currentX);
            const cropY = Math.min(cropStartY, currentY);
            const cropW = Math.abs(currentX - cropStartX);
            const cropH = Math.abs(currentY - cropStartY);
            
            updateCropOverlay(cropX, cropY, cropW, cropH);
            
            // Update input fields
            document.getElementById('cropX').value = Math.round(cropX);
            document.getElementById('cropY').value = Math.round(cropY);
            document.getElementById('cropW').value = Math.round(cropW);
            document.getElementById('cropH').value = Math.round(cropH);
        }

        function endCrop() {
            isDragging = false;
            updateCropPreview(); // Update preview when crop is finished
        }

        function updateCropOverlay(x, y, w, h) {
            const overlay = document.getElementById('cropOverlay');
            if (!overlay) return;
            
            // Only show overlay if crop is active (not full image)
            if (isCropActive()) {
                overlay.style.left = x + 'px';
                overlay.style.top = y + 'px';
                overlay.style.width = w + 'px';
                overlay.style.height = h + 'px';
                overlay.style.display = 'block';
                overlay.style.border = '2px solid #B91D30';
                overlay.style.backgroundColor = 'rgba(185, 29, 48, 0.1)';
            } else {
                overlay.style.display = 'none';
            }
            
            console.log('Crop overlay updated:', {x, y, w, h, active: isCropActive()});
        }

        function updateCropPreview() {
            if (!currentImage) return;
            
            // Don't show the preview image until detect button is pressed
            // This function now only updates the crop overlay, not the result image
            const canvas = document.getElementById('imagePreview');
            const cropX = parseInt(document.getElementById('cropX').value) || 0;
            const cropY = parseInt(document.getElementById('cropY').value) || 0;
            const cropW = parseInt(document.getElementById('cropW').value);
            const cropH = parseInt(document.getElementById('cropH').value);
            
            // Update the crop overlay only
            updateCropOverlay(cropX, cropY, cropW, cropH);
            
            console.log('Crop preview updated (overlay only):', {
                crop: {x: cropX, y: cropY, w: cropW, h: cropH},
                canvas: {w: canvas.width, h: canvas.height},
                rotation: currentRotation,
                flip: currentFlip
            });
        }

        function updateCropFromInputs() {
            const x = parseInt(document.getElementById('cropX').value) || 0;
            const y = parseInt(document.getElementById('cropY').value) || 0;
            const w = parseInt(document.getElementById('cropW').value) || 0;
            const h = parseInt(document.getElementById('cropH').value) || 0;
            
            updateCropOverlay(x, y, w, h);
            updateCropPreview(); // Update the preview after crop changes
            console.log('Crop updated from inputs:', {x, y, w, h, active: isCropActive()});
        }

        function isCropActive() {
            const cropW = parseInt(document.getElementById('cropW').value);
            const cropH = parseInt(document.getElementById('cropH').value);
            const canvas = document.getElementById('imagePreview');
            
            // Check if crop dimensions are different from full canvas dimensions
            return cropW && cropH && 
                   (cropW < canvas.width || cropH < canvas.height || 
                    parseInt(document.getElementById('cropX').value) > 0 || 
                    parseInt(document.getElementById('cropY').value) > 0);
        }

        function resetCrop() {
            if (!currentImage) return;
            
            const canvas = document.getElementById('imagePreview');
            document.getElementById('cropX').value = 0;
            document.getElementById('cropY').value = 0;
            document.getElementById('cropW').value = canvas.width;  // Use full canvas width
            document.getElementById('cropH').value = canvas.height; // Use full canvas height
            
            // Clear the crop overlay
            updateCropOverlay(0, 0, canvas.width, canvas.height);
            updateCropPreview(); // Update preview after reset
            console.log('Crop reset to full image');
        }

        function rotateImage(degrees) {
            currentRotation = (currentRotation + degrees) % 360;
            if (currentRotation < 0) currentRotation += 360;
            
            document.getElementById('rotationAngle').textContent = currentRotation + '째';
            
            if (currentImage) {
                displayImagePreview(selectedFile);
                updateCropPreview(); // Update preview after rotation
            }
        }

        function flipImage(direction) {
            if (direction === 'horizontal') {
                currentFlip.horizontal = !currentFlip.horizontal;
            } else if (direction === 'vertical') {
                currentFlip.vertical = !currentFlip.vertical;
            }
            
            const flipStatus = [];
            if (currentFlip.horizontal) flipStatus.push('H');
            if (currentFlip.vertical) flipStatus.push('V');
            document.getElementById('flipStatus').textContent = flipStatus.length > 0 ? flipStatus.join(', ') : 'None';
            
            if (currentImage) {
                displayImagePreview(selectedFile);
                updateCropPreview(); // Update preview after flip
            }
        }

        async function loadModelWeights(preserveSelection = '') {
            console.log('loadModelWeights called with preserveSelection:', preserveSelection);
            try {
                console.log('Fetching /api/dinov3_weights...');
                const response = await fetch('/api/dinov3_weights');
                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('API response:', data);
                
                const select = document.getElementById('modelSelect');
                select.innerHTML = '<option value="">Select a model...</option>';
                
                if (data.success && data.weights.length > 0) {
                    console.log('Loading', data.weights.length, 'weights into dropdown');
                    data.weights.forEach((weight, index) => {
                        console.log(`Weight ${index + 1}:`, weight.display_name);
                        const option = document.createElement('option');
                        option.value = weight.path;
                        option.textContent = weight.display_name;
                        select.appendChild(option);
                    });
                    
                    // Restore previous selection if provided
                    if (preserveSelection) {
                        select.value = preserveSelection;
                        console.log('Restored selection to:', preserveSelection);
                    }
                    
                    // Enable the dropdown after loading models
                    select.disabled = false;
                    console.log('Model dropdown enabled with', data.weights.length, 'weights');
                } else {
                    console.log('No weights found or API error');
                    select.innerHTML = '<option value="">No models found</option>';
                    select.disabled = false;
                }
            } catch (error) {
                console.error('Error loading model weights:', error);
                document.getElementById('modelSelect').innerHTML = '<option value="">Error loading models</option>';
                document.getElementById('modelSelect').disabled = false;
            }
        }

        function enableModelSelection() {
            console.log('enableModelSelection called');
            // Always load models when image is displayed
            const select = document.getElementById('modelSelect');
            console.log('Model select element:', select);
            console.log('Model select disabled:', select.disabled);
            
            // Preserve currently selected weight
            const currentSelection = select.value;
            console.log('Current selection:', currentSelection);
            
            console.log('Loading model weights after image display...');
            loadModelWeights(currentSelection);
        }

        function setupBatchNavigation() {
            const prevBtn = document.getElementById('prevImageBtn');
            const nextBtn = document.getElementById('nextImageBtn');
            
            prevBtn.addEventListener('click', () => {
                if (currentBatchIndex > 0) {
                    currentBatchIndex--;
                    selectedFile = batchFiles[currentBatchIndex];
                    displayImagePreview(selectedFile);
                    updateBatchCounter();
                    updateBatchButtons();
                }
            });
            
            nextBtn.addEventListener('click', () => {
                if (currentBatchIndex < batchFiles.length - 1) {
                    currentBatchIndex++;
                    selectedFile = batchFiles[currentBatchIndex];
                    displayImagePreview(selectedFile);
                    updateBatchCounter();
                    updateBatchButtons();
                }
            });
        }

        function showBatchNavigation() {
            const batchNav = document.getElementById('batchNavigation');
            batchNav.style.display = 'block';
            updateBatchCounter();
            updateBatchButtons();
        }

        function hideBatchNavigation() {
            const batchNav = document.getElementById('batchNavigation');
            batchNav.style.display = 'none';
        }

        function updateBatchCounter() {
            const counter = document.getElementById('batchCounter');
            counter.textContent = `Image ${currentBatchIndex + 1} of ${batchFiles.length}`;
        }

        function updateBatchButtons() {
            const prevBtn = document.getElementById('prevImageBtn');
            const nextBtn = document.getElementById('nextImageBtn');
            
            prevBtn.disabled = currentBatchIndex === 0;
            nextBtn.disabled = currentBatchIndex === batchFiles.length - 1;
        }

        async function detectImage() {
            if (!selectedFile) {
                showMessage('Please select an image first', 'error');
                return;
            }

            const modelSelect = document.getElementById('modelSelect');
            if (!modelSelect.value) {
                showMessage('Please select a model weight', 'error');
                return;
            }

            const detectBtn = document.getElementById('detectBtn');
            const loading = document.getElementById('loading');
            const detectionResultsContainer = document.getElementById('detectionResultsContainer');

            // Show loading state
            detectBtn.disabled = true;
            loading.style.display = 'block';
            detectionResultsContainer.style.display = 'block';
            hideMessages();

            try {
                // Get crop coordinates
                const cropX = parseInt(document.getElementById('cropX').value) || 0;
                const cropY = parseInt(document.getElementById('cropY').value) || 0;
                const cropW = parseInt(document.getElementById('cropW').value);
                const cropH = parseInt(document.getElementById('cropH').value);
                
                const canvas = document.getElementById('imagePreview');
                let finalCropX, finalCropY, finalCropW, finalCropH;
                
                // Check if a crop is active (not full image)
                if (isCropActive()) {
                    // Convert from canvas coordinates to original image coordinates
                    const scaleX = currentImage.width / canvas.width;
                    const scaleY = currentImage.height / canvas.height;
                    
                    finalCropX = Math.round(cropX * scaleX);
                    finalCropY = Math.round(cropY * scaleY);
                    finalCropW = Math.round(cropW * scaleX);
                    finalCropH = Math.round(cropH * scaleY);
                    
                    console.log('Crop is active - detecting only cropped area');
                } else {
                    // Use full image
                    finalCropX = 0;
                    finalCropY = 0;
                    finalCropW = currentImage.width;
                    finalCropH = currentImage.height;
                    
                    console.log('No crop active - detecting full image');
                }
                
                // Ensure crop coordinates are within image bounds
                finalCropX = Math.max(0, Math.min(finalCropX, currentImage.width));
                finalCropY = Math.max(0, Math.min(finalCropY, currentImage.height));
                finalCropW = Math.max(1, Math.min(finalCropW, currentImage.width - finalCropX));
                finalCropH = Math.max(1, Math.min(finalCropH, currentImage.height - finalCropY));
                
                // Debug logging
                console.log('Detection Debug Info:');
                console.log('Original image size:', currentImage.width, 'x', currentImage.height);
                console.log('Canvas size:', canvas.width, 'x', canvas.height);
                console.log('Crop input values:', cropX, cropY, cropW, cropH);
                console.log('Final crop coords:', finalCropX, finalCropY, finalCropW, finalCropH);
                console.log('Crop active:', isCropActive());
                
                const formData = new FormData();
                formData.append('file', selectedFile);
                formData.append('weight_path', modelSelect.value);
                formData.append('crop_x', finalCropX);
                formData.append('crop_y', finalCropY);
                formData.append('crop_w', finalCropW);
                formData.append('crop_h', finalCropH);
                formData.append('rotation', currentRotation);
                formData.append('flip_horizontal', currentFlip.horizontal);
                formData.append('flip_vertical', currentFlip.vertical);

                const response = await fetch('/api/detect_dinov3', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (data.success) {
                    displayResults(data);
                } else {
                    showMessage(data.error || 'Detection failed', 'error');
                }
            } catch (error) {
                console.error('Detection error:', error);
                showMessage('Network error during detection', 'error');
            } finally {
                detectBtn.disabled = false;
                loading.style.display = 'none';
            }
        }

        function displayResults(data) {
            // Update performance stats - ensure all fields are updated with null checks
            const inferenceTimeEl = document.getElementById('inferenceTime');
            const architectureEl = document.getElementById('architecture');
            const modelSizeEl = document.getElementById('modelSize');
            const inputSizeEl = document.getElementById('inputSize');
            const batchSizeEl = document.getElementById('batchSize');
            
            if (inferenceTimeEl && data.inference_time !== undefined) {
                inferenceTimeEl.textContent = `${data.inference_time.toFixed(1)}ms`;
            }
            if (architectureEl) {
                architectureEl.textContent = data.architecture || '--';
            }
            if (modelSizeEl) {
                modelSizeEl.textContent = data.model_size || '--';
            }
            if (inputSizeEl) {
                inputSizeEl.textContent = data.input_size || '--';
            }
            if (batchSizeEl) {
                batchSizeEl.textContent = data.batch_size || '--';
            }

            // Display image
            const resultImage = document.getElementById('resultImage');
            resultImage.src = data.image;
            
            // Add load event to ensure image displays correctly
            resultImage.onload = function() {
                console.log('Result image loaded successfully');
                console.log('Result image dimensions:', this.naturalWidth, 'x', this.naturalHeight);
                console.log('Result image display dimensions:', this.width, 'x', this.height);
            };
            
            resultImage.onerror = function() {
                console.error('Failed to load result image');
            };

            // Display prediction
            const predictionResult = document.getElementById('predictionResult');
            const predictionClass = document.getElementById('predictionClass');
            const predictionConfidence = document.getElementById('predictionConfidence');

            predictionClass.textContent = data.predicted_class;
            predictionConfidence.textContent = `Confidence: ${(data.confidence * 100).toFixed(1)}%`;
            predictionResult.style.display = 'block';

            // Display top 3 predictions
            if (data.top3_predictions && data.top3_predictions.length >= 3) {
                const prediction1 = document.getElementById('prediction1');
                const prediction2 = document.getElementById('prediction2');
                const prediction3 = document.getElementById('prediction3');
                
                prediction1.textContent = `1. ${data.top3_predictions[0].class}: ${data.top3_predictions[0].probability.toFixed(4)}`;
                prediction2.textContent = `2. ${data.top3_predictions[1].class}: ${data.top3_predictions[1].probability.toFixed(4)}`;
                prediction3.textContent = `3. ${data.top3_predictions[2].class}: ${data.top3_predictions[2].probability.toFixed(4)}`;
            }

            showMessage(`Detection completed successfully!`, 'success');
        }

        function showMessage(message, type) {
            console.log('showMessage called:', message, type);
            hideMessages();
            const messageDiv = document.getElementById(type === 'error' ? 'errorMessage' : 'successMessage');
            console.log('Message div found:', messageDiv);
            if (messageDiv) {
                messageDiv.textContent = message;
                messageDiv.style.display = 'block';
                console.log('Message displayed:', message);
            } else {
                console.error('Message div not found for type:', type);
            }
        }

        function hideMessages() {
            document.getElementById('errorMessage').style.display = 'none';
            document.getElementById('successMessage').style.display = 'none';
        }
    </script>
</body>
</html>
